<!DOCTYPE html>
<html>
<head>
	<title>Block Breaker</title>
	<style>
		canvas {
			display: block;
			margin: 50px auto;
			background-color: #ededed;
			border: 1px solid #000;
			width: 960px;
			height: 540px;
		}
	</style>
</head>

<body onload="startGame()">

<canvas id="game"></canvas>
<p>
	<p id="log"></p>
</p>
<script>

	//global values
	var width = 960;
	var height = 540;

	//default object values
	var maxBallSpeed = 5;
	var default_block_width = 100;
	var default_block_height = 50;

	//helper elements
	var partition_block;

	//game pieces
	var myGamePiece;
	var myPaddle;
	var myBlock;

	var balls = [];
	var blocks = [];

	var isPaused = false;

	function startGame() {
		myPaddle = new paddle();
		myBlock = new block( 100, 50, "#0f0", 100, 100 );
		balls.push( new ball( 15, 15, "blue", (width / 2) - 7, 300 ) );

		//setup the block layout
        level1_layout( );

		myGameArea.start( );
	}

	function ball( width, height, color, x, y ) {
		this.width = width;
		this.height = height;
		this.spdX = 0;
		this.spdY = maxBallSpeed;
		this.x = x;
		this.y = y;

		//empty edges, initialized in update function
		this.top_edge, this.bottom_edge, this.left_edge, this.right_edge;

		this.update = function() {
			ctx = myGameArea.context;
			ctx.fillStyle = color;
			ctx.fillRect( this.x, this.y, this.width, this.height );
		}
		this.newPos = function() {
			this.x += this.spdX;
			this.y += this.spdY;
			//edges
			this.top_edge = this.y;
			this.bottom_edge = this.top_edge + this.height;
			this.left_edge = this.x;
			this.right_edge = this.left_edge + this.width;
		}
	}

	function block( width, height, color, x, y, health = 1 ) {
		this.width = width;
		this.height = height;
		this.spdX = 0;
		this.spdY = 0;
		this.x = x;
		this.y = y;
		this.health = health;

		//edges
		this.top_edge = this.y;
		this.bottom_edge = this.top_edge + this.height;
		this.left_edge = this.x;
		this.right_edge = this.left_edge + this.width;

		this.update = function() {
			ctx = myGameArea.context;
			ctx.fillStyle = color;
			ctx.fillRect( this.x, this.y, this.width, this.height );
		}

		this.newPos = function() {
			this.x += this.spdX;
			this.y += this.spdY;
		}

		this.collision = function( obj ) {
			//hit the left side of block
			if ( ( obj.top_edge >= this.bottom_edge && obj.bottom_edge <= this.top_edge ) && ( obj.right_edge >= this.left_edge && obj.right_edge <= this.right_edge ) ) {
				dbgr.add( "LEFT" );
				obj.spdX *= -1;

				--health;

				if ( health == 0 ) {
					return true;
				}
			}
			else if ( ( obj.top_edge >= this.bottom_edge && obj.bottom_edge <= this.top_edge ) && ( obj.right_edge <= this.left_edge && obj.right_edge >= this.right_edge ) ) {
				dbgr.add( "TOP" );
				obj.spdX *= -1;

				--health;

				if ( health == 0 ) {
					return true;
				}
			}
			//hit bottom of block
			else if ( ( obj.top_edge <= this.bottom_edge && obj.top_edge >= this.top_edge ) && ( obj.right_edge >= this.left_edge && obj.left_edge <= this.right_edge ) ) {
				dbgr.add( "BOTTOM" );
				obj.spdY *= -1;
				--health;

				if ( health == 0 ) {
					return true;
				}
			} 
			//hit top of block
			else if ( ( obj.bottom_edge >= this.top_edge && obj.bottom_edge <= this.bottom_edge ) && ( obj.right_edge >= this.left_edge && obj.left_edge <= this.right_edge ) ) {
				dbgr.add( "TOP" );
				obj.spdY *= -1;
				
				--health;

				if ( health == 0 ) {
					return true;
				}
			}
		}
	}

	function paddle() {
		this.width = 100;
		this.height = 7;
		this.x = width / 2 - 50;
		this.y = height - 75;
		this.numberHits = 0;
		this.update = function() {
			ctx = myGameArea.context;
			ctx.fillStyle = "#000";
			ctx.fillRect( this.x, this.y, this.width, this.height );
		}

		//move the paddle as the mouse moves within the bounds of the canvas
		this.newPos = function( x, y ) {
			if ( x <= myGameArea.canvas.width - 100 && x >= 0 )
				this.x = x;
		}

		//check if there was a collision with the paddle
		this.collision = function( obj ) {
			//if the left most side is less than the width of the paddle or the right most side is greater than the x position
			//and the bottom side is less that the top of the paddle
			if ( ( obj.x <= this.x + this.width && obj.x + obj.width >= this.x ) && ( obj.y + obj.height >= this.y && obj.y <= this.y + this.height ) ) {
				this.bounceBack(obj);
				++this.numberHits;
				//dbgr.add( this.numberHits + " PADDLE HIT");
			}
		}

		this.bounceBack = function( obj ) {
			//first, get the location of the ball in relation to the length of the paddle and turn it into a percentage
			var total_paddle_width = this.width;
			var xpos = obj.x + (obj.width / 2);
			var xpercentage = (xpos - this.x) / total_paddle_width;
			//console.log( xpos + " - " + this.x + " / " + total_paddle_width + " = " + xpercentage + "%" );

			//now, find where the ball is along the length of the paddle
			//and determine how the ball will bound
			if ( xpercentage < .40 ) {
				//if the ball hits the left 40% of the paddle, multiply by the negative max speed by the location of the ball on the left 50% of the paddle
				var left_percentage = (.50 - xpercentage) / .50;
				obj.spdX = ( maxBallSpeed * left_percentage ) * -1;
				obj.spdY *= -1;
			} else if ( xpercentage >= .40 && xpercentage <= .60 ) {
				//if the ball hits the middle 20% of the paddle, 40%-60%, the ball just changes it's Y speed
				obj.spdY *= -1;
			} else if ( xpercentage > .60 ) {
				//if the ball hits the right 40% of the paddle, multiple by the max speed and the location of the ball of the right 50% of the paddle
				var right_percentage = (xpercentage - .50) / .50;
				obj.spdX = (maxBallSpeed * right_percentage);
				obj.spdY *= -1;
			}
		}
	}

	var myGameArea = {
	    canvas : document.getElementById("game"),

	    start : function() {
	    	this.canvas.width = width;
	    	this.canvas.height = height;
	        this.context = this.canvas.getContext("2d");
	        this.interval = setInterval( updateGameArea, 20 );

        	//canvas event listeners
	        window.addEventListener('keydown', function(e) {	        	
	        	// myGameArea.keys = (myGameArea.keys || []);
	        	// myGameArea.keys[e.keyCode] = true;
	        	dbgr.add("KEYCODE: " + e.keyCode);
	        	if ( e.keyCode == 27 && isPaused == false ) {
	        		isPaused = true;
	        	} else if ( e.keyCode == 27 && isPaused == true ) {
	        		isPaused = false;
	        	}
	        })

	        window.addEventListener('keyup', function(e){
	        	// myGameArea.keys[e.keyCode] = false;
	        })

	        window.addEventListener('click', function(e) {
	        	balls.push( new ball( 15, 15, "red", (width / 2) - 7, 100 ) );
	        })
	    },

	    clear : function() {
	    	this.context.clearRect( 0, 0, this.canvas.width, this.canvas.height );
	    },

	    collision : function( obj ) {
    		if ( obj.x + obj.width >= this.canvas.width ) {
    			obj.spdX *= -1;
    			//dbgr.add( "Right" );
    		}
    		else if ( obj.x <= 0 ) {
    			obj.spdX *= -1;
    			//dbgr.add( "Left" );
    		}
    		else if ( obj.y + obj.height >= this.canvas.height ) {
    			obj.spdY *= -1;
    			//dbgr.add( "Bottom" );
    		}
    		else if ( obj.y <= 0 ) {
    			obj.spdY *= -1;
    			//dbgr.add( "Top" );
    		}
	    }
	}

	function updateGameArea() {
		if ( !isPaused ) {
			myGameArea.clear();

			//logic

			myPaddle.update();

			for ( var i = 0; i < balls.length; ++i ) {
				myGameArea.collision( balls[i] );
				myPaddle.collision( balls[i] );

				for ( var j = 0; j < blocks.length; ++j ) {
					if ( blocks[j].collision( balls[i] ) ) {
						blocks.splice( j, 1 );
					}
					blocks[j].update();
				}

				balls[i].newPos();
				balls[i].update();
			}

			// document.getElementById("x").innerHTML = myGamePiece.x;
			// document.getElementById("y").innerHTML = myGamePiece.y;
		} else if ( isPaused ) {
			myGameArea.context.font = "50px Arial";
			myGameArea.context.fillStyle = "red";
			myGameArea.context.textAlign = "center";
			myGameArea.context.fillText( "Paused", width/2, height/2 );
		}
	}

	var dbgr = {
		ele : document.getElementById("log"),
		add : function(msg) {
			//console.log("working");
			this.ele.innerHTML = msg + "<br>" + this.ele.innerHTML;
		}
	}

	//http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
	//tracking the mouse coordinates
	//------------------------------------------------------------------------------------------------------------
	function getMousePos(canvas, e) {
        var rect = document.getElementById("game").getBoundingClientRect();
        return {
        	x: e.clientX - rect.left,
        	y: e.clientY - rect.top
    	};
	}

	document.getElementById("game").addEventListener('mousemove', function(e) {
		var mousePos = getMousePos(document.getElementById("game"), e);
        myPaddle.newPos( mousePos.x, mousePos.y );
    }, false);
    //------------------------------------------------------------------------------------------------------------

    //create a grid of block objects
	//------------------------------------------------------------------------------------------------------------
	function level1_layout( ) {
		dbgr.add("BUiLD GRiD");
        var partition_width = width * .75;
        var partition_height = height * .40; 
        var margin_left = ( width - partition_width ) / 2
        var margin_top = 50;

        //partition_block = new block( partition_width, partition_height, "#fff", margin_left, margin_top );

        for ( var i = 0; i < 3; ++i ) {
    		var ypos = margin_top + ( ( default_block_height * i ) + ( 10 * i ) );
        	for ( var j = 0; j < 6; ++j ) {
        		var xpos = margin_left + ( ( default_block_width * j ) + ( 10 * j ) );

        		var new_block = new block( default_block_width, default_block_height, "#0f0", xpos, ypos, 2 );
        		blocks.push( new_block );
        		//new_block.draw();
        	}
        }
	}
    //------------------------------------------------------------------------------------------------------------
</script>
</body>
</html>